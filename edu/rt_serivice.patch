diff --git a/edu/rt_serivice.patch b/edu/rt_serivice.patch
index 0d09cc3..e69de29 100644
--- a/edu/rt_serivice.patch
+++ b/edu/rt_serivice.patch
@@ -1,128 +0,0 @@
-diff --git a/graphics_view/ut/graphics_view_ut.cpp b/graphics_view/ut/graphics_view_ut.cpp
-index c5f3d52..3df4e70 100644
---- a/graphics_view/ut/graphics_view_ut.cpp
-+++ b/graphics_view/ut/graphics_view_ut.cpp
-@@ -8,7 +8,7 @@ namespace rtc
- namespace ut
- {
- 
--TEST(graphics_view_ut, basic_move)
-+TEST(graphics_view_ut, DISABLED_basic_move)
- {
-   auto data = std::make_shared<rtc::brs>("room.xml");
-   rtc::graphics_view<> g{data};
-diff --git a/rt_service/include/rt_service.hpp b/rt_service/include/rt_service.hpp
-index af669ff..c80a30e 100644
---- a/rt_service/include/rt_service.hpp
-+++ b/rt_service/include/rt_service.hpp
-@@ -50,27 +50,35 @@ public:
- 
- private:
-   rt_service();
-+
-+  struct param_pack
-+  {
-+    param_pack(rtc::math_ray r) : ray{std::move(r)}, result{}
-+    {}
-+
-+    rtc::math_ray ray;
-+    std::promise<rtc::intersection> result;
-+  };
-+
-   struct control_block_t
-   {
-     std::unique_ptr<const ray_tracer> rt_search;
- 
-     boost::thread_group threads;
--    std::array<rtc::math_ray, queue_capacity> ray_slots;
--    std::array<std::promise<rtc::intersection>, queue_capacity> promise_slots;
--    thread_safe_queue<std::uint16_t, queue_capacity> free_slots, used_slots;
-+    std::unique_ptr<thread_safe_queue<param_pack*, queue_capacity>[]> queue_slots;
-   };
- 
--  static void thread_execution_loop(control_block_t&);
-+  static void thread_execution_loop(std::uint32_t, control_block_t&, std::size_t);
-   std::unique_ptr<control_block_t> control{std::make_unique<control_block_t>()};
- };
- 
- template<typename T>
- rt_service<T>::rt_service()
- {
--  for(std::uint32_t i{0}; i < std::max(1u, thread_number() - 1u); ++i)
--      control->threads.create_thread([p = control.get()](){ thread_execution_loop(*p); });
-+  control->queue_slots = std::make_unique<thread_safe_queue<param_pack*, queue_capacity>[]>(thread_number() - 1);
- 
--  for(auto i{0}; i < queue_capacity; control->free_slots.push(i++)){}
-+  for(std::uint32_t i{0}; i < std::max(1u, thread_number() - 1u); ++i)
-+      control->threads.create_thread([i, p = control.get(), this](){ thread_execution_loop(i, *p, thread_number() - 1); });
- }
- 
- template<typename T>
-@@ -99,43 +107,48 @@ auto rt_service<T>::trace_ray(const rtc::math_ray& ray) -> trace_result
-   if(rtc_unlikely(!control))
-     throw std::runtime_error{"ray_trace is not able to trace, probably it was moved from"};
- 
--  std::promise<rtc::intersection> p{};
--  auto result{p.get_future()};
--  const auto thread_fn = [this, &ray, &p](auto free_slot_index)
--  {
--    control->ray_slots[free_slot_index] = ray;
--    control->promise_slots[free_slot_index] = std::move(p);
--    control->used_slots.push(free_slot_index);
--  };
-+  auto data = std::make_unique<param_pack>(ray);
-+  auto result{data->result.get_future()};
-+  auto raw_pointer = data.release();
-+
-+  static std::size_t n{0};
-+  while(!control->queue_slots[n = (n++) % (thread_number() - 1)].push(raw_pointer)){}
- 
--  while(!control->free_slots.consume_one(thread_fn)){}
-   return result;
- }
- 
- template<typename T>
--void rt_service<T>::thread_execution_loop(control_block_t& cb) try
-+void rt_service<T>::thread_execution_loop(std::uint32_t thread_id, control_block_t& cb, std::size_t tn) try
- {
-   SCOPE_TIME_COUNTER;
--  DEBUG << "Thread[" << boost::this_thread::get_id() << "] was started!!";
-+  DEBUG << "Thread[" << thread_id << "] was started!!";
- 
--  const auto thread_fn = [&cb](const auto slot_index)
-+  const auto thread_fn = [&cb](const auto slot)
-   {
--    const auto ray{cb.ray_slots[slot_index]};
--    auto promise{std::move(cb.promise_slots[slot_index])};
--    auto intersection{cb.rt_search->trace_ray(ray)};
-+    std::unique_ptr<param_pack> raii(slot);
- 
--    promise.set_value(std::move(intersection));
--    cb.free_slots.push(slot_index);
-+    auto intersection{cb.rt_search->trace_ray(raii->ray)};
-+    raii->result.set_value(std::move(intersection));
-   };
- 
-   while(boost::this_thread::interruption_point(), true)
-   {
--    cb.used_slots.consume_one(thread_fn);
-+    if(cb.queue_slots[thread_id].consume_one(thread_fn) == false)
-+    {
-+      auto n{thread_id};
-+      bool was_steal{false};
-+      do
-+      {
-+        n = (++n) % tn;
-+        was_steal = cb.queue_slots[n].consume_one(thread_fn);
-+      }
-+      while(n == thread_id || was_steal);
-+    }
-   }
- }
- catch(const boost::thread_interrupted&)
- {
--  DEBUG << "Thread[" << boost::this_thread::get_id() << "] was interrupted!!";
-+  DEBUG << "Thread[" << thread_id << "] was interrupted!!";
- }
- 
- }
diff --git a/rt_service/include/rt_service.hpp b/rt_service/include/rt_service.hpp
index 70d395f..35f7469 100644
--- a/rt_service/include/rt_service.hpp
+++ b/rt_service/include/rt_service.hpp
@@ -26,7 +26,7 @@ template<typename _rt = ::rtc::kdtree_rt>
 class rt_service
 {
   template<typename T>
-  using thread_safe_queue = boost::lockfree::queue<T, boost::lockfree::fixed_sized<true>>;
+  using thread_safe_queue = boost::lockfree::queue<T>;
 
 public:
   static constexpr std::size_t queue_capacity{256};
@@ -51,17 +51,23 @@ public:
 
 private:
   rt_service();
+
+  struct trace_pack {
+    rtc::math_ray r;
+    std::promise<rtc::intersection> p;
+  };
+
   struct control_block
   {
     std::unique_ptr<const ray_tracer> rt_search;
 
     boost::thread_group threads;
-    std::array<rtc::math_ray, queue_capacity> ray_slots;
-    std::array<std::promise<rtc::intersection>, queue_capacity> promise_slots;
-    thread_safe_queue<std::uint16_t> free_slots{queue_capacity}, used_slots{queue_capacity};
+    //std::array<rtc::math_ray, queue_capacity> ray_slots;
+    //std::array<std::promise<rtc::intersection>, queue_capacity> promise_slots;
+    std::unique_ptr<thread_safe_queue< trace_pack* >[]> queue{};
   };
 
-  static void thread_execution_loop(std::size_t, control_block&);
+  static void thread_execution_loop(std::size_t, control_block&, std::size_t);
   std::unique_ptr<control_block> control{std::make_unique<control_block>()};
 };
 
@@ -70,10 +76,10 @@ rt_service<T>::rt_service()
 {
   RELEASE << "Spawning threads... ";
 
-  for(std::uint32_t i{0}; i < thread_number(); ++i)
-      control->threads.create_thread([i, p = control.get()](){ thread_execution_loop(i, *p); });
+  control->queue = std::make_unique<thread_safe_queue<trace_pack*>[]>(thread_number());
 
-  for(auto i{0}; i < queue_capacity; control->free_slots.push(i++)){}
+  for(std::uint32_t i{0}; i < thread_number(); ++i)
+      control->threads.create_thread([i, p = control.get(), this](){ thread_execution_loop(i, *p, this->thread_number()); });
 }
 
 template<typename T>
@@ -102,40 +108,36 @@ auto rt_service<T>::trace_ray(const rtc::math_ray& ray) -> trace_result
   if(rtc_unlikely(!control))
     throw std::runtime_error{"ray_trace is not able to trace, probably it was moved from"};
 
-  std::promise<rtc::intersection> p{};
-  auto result{p.get_future()};
-  const auto thread_fn = [this, &ray, &p](auto free_slot_index) {
-    control->ray_slots[free_slot_index] = ray;
-    control->promise_slots[free_slot_index] = std::move(p);
+  auto f = std::make_unique<trace_pack>();
 
-    control->used_slots.push(free_slot_index);
-  };
+  f->r = ray;
+  auto result = f->p.get_future();
+  auto data = f.release();
 
-  while(!control->free_slots.consume_one(thread_fn)){}
+  static int n{0};
+  while(!control->queue[n = ((n + 1) % thread_number())].push(data)){}
 
   return result;
 }
 
 template<typename T>
-void rt_service<T>::thread_execution_loop(std::size_t thread_id, control_block& cb)
+void rt_service<T>::thread_execution_loop(std::size_t thread_id, control_block& cb, std::size_t tn)
 {
   std::random_device rd{};
   std::uint32_t work{}, total{}, stols{};
 
   auto random_sleep = [gen = std::mt19937(rd()),
-                       urand = std::uniform_int_distribution<>(200, 800)] () mutable
+                       urand = std::uniform_int_distribution<>(0, tn)] () mutable
   {
     return urand(gen);
   };
 
-  const auto thread_fn = [&cb](const auto slot_index)
+  const auto thread_fn = [&cb](const auto slot)
   {
-    const auto ray{cb.ray_slots[slot_index]};
-    auto promise{std::move(cb.promise_slots[slot_index])};
-    auto intersection{cb.rt_search->trace_ray(ray)};
+    auto intersection{cb.rt_search->trace_ray(slot->r)};
+    slot->p.set_value(std::move(intersection));
 
-    promise.set_value(std::move(intersection));
-    cb.free_slots.push(slot_index);
+    delete slot;
   };
 
   try
@@ -145,11 +147,19 @@ void rt_service<T>::thread_execution_loop(std::size_t thread_id, control_block&
 
     while(boost::this_thread::interruption_point(), true)
     {
-      if(!cb.used_slots.consume_one(thread_fn))
+      if(!cb.queue[thread_id].consume_one(thread_fn))
       {
         ++stols;
-        if(cb.used_slots.empty())
-          random_sleep();
+        //if(cb.queue[thread_id].empty())
+        //random_sleep();
+        //auto id{random_sleep()};
+        //bool was_stolen{false};
+        //do
+        //{
+          //id = (++id) % tn;
+          //was_stolen = cb.queue[id].consume_one(thread_fn);
+        //}
+        //while(id != thread_id && !was_stolen);
       }
       else
       {
